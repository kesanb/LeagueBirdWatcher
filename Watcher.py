import requests
from discord_webhook import DiscordWebhook
from datetime import datetime, timedelta
import os
import time
import sys
from dotenv import load_dotenv
import logging
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import gc

# .env„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø
load_dotenv()

# Discord Webhook URLs for each category
WEBHOOK_URLS = {
    'streamer': os.getenv('DISCORD_WEBHOOK_URL_STREAMER'),
    'friend': os.getenv('DISCORD_WEBHOOK_URL_FRIEND'),
    'smurf': os.getenv('DISCORD_WEBHOOK_URL_SMURF'),
    'troll': os.getenv('DISCORD_WEBHOOK_URL_TROLL')
}

# Áí∞Â¢ÉÂ§âÊï∞„ÅÆË™≠„ÅøËæº„ÅøÈÉ®ÂàÜ
def load_player_list():
    categories = {
        'streamer': os.getenv('STREAMER_LIST', ''),
        'friend': os.getenv('FRIEND_LIST', ''),
        'smurf': os.getenv('SMURF_LIST', ''),
        'troll': os.getenv('TROLL_LIST', '')
    }
    
    player_dict = {}
    nickname_to_player = {}
    player_categories = {}
    
    for category, player_list_str in categories.items():
        if not player_list_str:  # Á©∫ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            continue
            
        for player_info in player_list_str.split(','):
            player_info = player_info.strip()
            if not player_info:  # Á©∫„ÅÆË¶ÅÁ¥†„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                continue
                
            if ':' in player_info:
                nickname, name = player_info.split(':')
                player_dict[name] = nickname
                nickname_to_player[nickname] = name
            else:
                # „Ç≥„É≠„É≥„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Éã„ÉÉ„ÇØ„Éç„Éº„É†„Å™„Åó„Å®„Åó„Å¶ÁôªÈå≤
                name = player_info
                player_dict[name] = None
            
            player_categories[name] = category
    
    return player_dict, nickname_to_player, player_categories

# „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Åó„Å¶ÂÆöÁæ©
PLAYER_DICT, NICKNAME_TO_PLAYER, PLAYER_CATEGORIES = load_player_list()

# Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ§úË®º
if not PLAYER_DICT:
    raise ValueError("PLAYER_LISTÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÄÅÁÑ°Âäπ„Å™ÂΩ¢Âºè„Åß„Åô„ÄÇ")

if not WEBHOOK_URLS['streamer']:
    raise ValueError("DISCORD_WEBHOOK_URL_STREAMERÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")

if not WEBHOOK_URLS['friend']:
    raise ValueError("DISCORD_WEBHOOK_URL_FRIENDÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")

if not WEBHOOK_URLS['smurf']:
    raise ValueError("DISCORD_WEBHOOK_URL_SMURFÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")

if not WEBHOOK_URLS['troll']:
    raise ValueError("DISCORD_WEBHOOK_URL_TROLLÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ")

print("Áõ£Ë¶ñÂØæË±°„Éó„É¨„Ç§„É§„Éº:")
for player_name, nickname in PLAYER_DICT.items():
    print(f"- {nickname} ({player_name})")

# ÂÆöÊï∞„ÅÆË®≠ÂÆö
POROFESSOR_BASE_URL = "https://porofessor.gg/live/jp/"

# „Éó„É¨„Ç§„É§„Éº„Åî„Å®„ÅÆÊúÄÂ§ß‰øùÂ≠ò„Éû„ÉÉ„ÉÅÊï∞„Çí2„Å´Â§âÊõ¥
MAX_MATCHES_PER_PLAYER = 2

# ÊúÄÂæå„ÅÆ„Éû„ÉÉ„ÉÅÊÉÖÂ†±„Çí‰øùÂ≠ò„Åô„ÇãËæûÊõ∏
last_match_info = {}

# „É≠„Ç∞„ÅÆË®≠ÂÆö
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Ëµ∑ÂãïÊôÇ„ÅÆ„É≠„Ç∞
logging.info("=== „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ëµ∑Âãï ===")
logging.info(f"Ëµ∑ÂãïÊôÇÂàª: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
logging.info("Áõ£Ë¶ñÂØæË±°„Éó„É¨„Ç§„É§„Éº:")
for player_name, nickname in PLAYER_DICT.items():
    logging.info(f"- {nickname} ({player_name})")
logging.info("========================")

# Áí∞Â¢ÉÂ§âÊï∞„ÅÆË™≠„ÅøËæº„Åø
SAVE_HTML_LOG = os.getenv('SAVE_HTML_LOG', 'false').lower() == 'true'

def save_html_log(player_name, content):
    """HTML„É¨„Çπ„Éù„É≥„Çπ„Çí„É≠„Ç∞„Å®„Åó„Å¶‰øùÂ≠ò„Åô„ÇãÈñ¢Êï∞Ôºà„É≠„Ç∞Âá∫Âäõ„Å™„ÅóÔºâ"""
    if not SAVE_HTML_LOG:
        return
        
    # logs„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    
    # „Éó„É¨„Ç§„É§„ÉºÂêç„Åã„ÇâÂÆâÂÖ®„Å™„Éï„Ç°„Ç§„É´Âêç„Çí‰ΩúÊàê
    safe_name = player_name.replace('#', '-').replace(':', '_')
    
    # ÁèæÂú®„ÅÆÊó•ÊôÇ„Çí„Éï„Ç°„Ç§„É´Âêç„Å´Âê´„ÇÅ„Çã
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"{safe_name}_{timestamp}.html"
    
    # „É≠„Ç∞„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò
    log_path = log_dir / filename
    try:
        with open(log_path, 'w', encoding='utf-8') as f:
            for chunk in content.split('\n'):
                f.write(chunk + '\n')
    except Exception as e:
        logging.error(f"HTML„É≠„Ç∞„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: {str(e)}")

def check_all_players():
    match_groups = {}
    not_found_players = []
    
    # „Éó„É¨„Ç§„É§„Éº„Çí‰∏Ä‰∫∫„Åö„Å§È†ÜÁï™„Å´„ÉÅ„Çß„ÉÉ„ÇØ
    for player_name in PLAYER_DICT.keys():
        try:
            result = check_player_status(player_name)
            
            if result:
                if result == "not_found":
                    not_found_players.append((player_name, PLAYER_DICT[player_name]))
                    logging.info(f"{PLAYER_DICT[player_name]}({player_name})„ÅÆË©¶ÂêàÊÉÖÂ†±„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü")
                else:
                    match_id = result['match_id']
                    if match_id not in match_groups:
                        match_groups[match_id] = []
                    result['nickname'] = PLAYER_DICT[player_name]
                    match_groups[match_id].append(result)
                    logging.info(f"{PLAYER_DICT[player_name]}({player_name})„ÅÆË©¶Âêà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü: {result['game_type']}")
                    
        except Exception as e:
            logging.error(f"„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„ÅüÔºà{PLAYER_DICT[player_name]}({player_name})Ôºâ: {str(e)}")
            continue
        
        # „Éó„É¨„Ç§„É§„Éº„Åî„Å®„Å´Â∞ë„ÅóÂæÖÊ©üÔºà„Çµ„Éº„Éê„ÉºË≤†Ëç∑ËªΩÊ∏õ„ÅÆ„Åü„ÇÅÔºâ
        #time.sleep(1)
    
    # ÁµêÊûú„ÅÆÂá¶ÁêÜ
    if match_groups or not_found_players:
        send_discord_notification(match_groups, not_found_players)
    
    # ‰ΩøÁî®Ê∏à„Åø„Éá„Éº„Çø„ÅÆÊòéÁ§∫ÁöÑ„Å™„ÇØ„É™„Ç¢
    match_groups.clear()
    not_found_players.clear()

def send_discord_notification(match_groups, not_found_players):
    category_messages = {category: [] for category in WEBHOOK_URLS.keys()}
    
    current_time = (datetime.now() + timedelta(hours=9)).strftime('%YÂπ¥%mÊúà%dÊó• %H:%M:%S')
    
    for match_id, players in match_groups.items():
        # „Éû„ÉÉ„ÉÅ„Åî„Å®„Å´„É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê
        match_message = f"> üéÆ **Match Found!**\n> {current_time}\n\n"
        match_message += f"‚ñº **Ë©¶ÂêàÊÉÖÂ†±**\n"
        
        # „Ç´„ÉÜ„Ç¥„É™„Åî„Å®„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÇíÂàÜÈ°û
        category_players = {category: [] for category in WEBHOOK_URLS.keys()}
        game_type = players[0]['game_type']
        url = players[0]['url']
        
        for player in players:
            category = PLAYER_CATEGORIES.get(player['player_name'], 'friend')
            if player['nickname']:
                player_info = f"`{player['nickname']}:{player['player_name']}({player['champion']})`"
            else:
                player_info = f"`{player['player_name']}({player['champion']})`"
            category_players[category].append(player_info)
        
        # „Ç´„ÉÜ„Ç¥„É™„Åî„Å®„Å´„É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê
        for category, player_list in category_players.items():
            if player_list:  # „Åù„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà
                category_message = match_message
                players_info = " / ".join(player_list)
                category_message += f"> „Éó„É¨„Ç§„É§„ÉºÔºö{players_info}\n"
                category_message += f"> Ë©¶Âêà„Çø„Ç§„ÉóÔºö`{game_type}`\n> {url}\n\n"
                category_messages[category].append(category_message)
    
    # „Ç´„ÉÜ„Ç¥„É™„Åî„Å®„Å´Webhook„ÇíÈÄÅ‰ø°
    for category, messages in category_messages.items():
        if messages and WEBHOOK_URLS[category]:
            webhook = DiscordWebhook(url=WEBHOOK_URLS[category], content=''.join(messages))
            webhook.execute()

# „Ç∞„É≠„Éº„Éê„É´„Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰ΩúÊàê
class SessionManager:
    _session = None
    
    @classmethod
    def get_session(cls):
        if cls._session is None:
            cls._session = requests.Session()
            retry_strategy = Retry(
                total=3,
                backoff_factor=0.5,
                status_forcelist=[500, 502, 503, 504]
            )
            adapter = HTTPAdapter(max_retries=retry_strategy)
            cls._session.mount("http://", adapter)
            cls._session.mount("https://", adapter)
        return cls._session

# „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Åó„Å¶ËøΩÂä†
not_found_player_notifications = {}  # {player_name: last_notification_time}

def check_player_status(player_name):
    url_player_name = player_name.replace('#', '-')
    main_url = f"https://porofessor.gg/live/jp/{url_player_name}"
    
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Referer': 'https://porofessor.gg/',
        'Cache-Control': 'no-cache'
    }
    
    try:
        logging.info(f"Ê§úÁ¥¢URL: {main_url}")
        
        session = SessionManager.get_session()
        response = session.get(main_url, headers=headers, timeout=10)
        if response is None:
            category = PLAYER_CATEGORIES.get(player_name, 'friend')
            webhook = DiscordWebhook(
                url=WEBHOOK_URLS[category],
                content=f"‚ö†Ô∏è **„Ç®„É©„Éº**: `{PLAYER_DICT[player_name]}` (`{player_name}`) „ÅÆÊÉÖÂ†±ÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ\n„Éó„É¨„Ç§„É§„ÉºÂêç„ÅåÈñìÈÅï„Å£„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁ¢∫Ë™ç„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ"
            )
            webhook.execute()
            print(f'„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: „É¨„Çπ„Éù„É≥„Çπ„Åå None „Åß„Åô')
            return "error"
                
        content = response.text.lower()
        
        save_html_log(player_name, content)
        
        display_name = PLAYER_DICT[player_name] if PLAYER_DICT[player_name] else player_name
        
        # „Éó„É¨„Ç§„É§„Éº„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆÂà§ÂÆö
        not_found_patterns = [
            'Summoner not found',
            'summoner not found',
            '404 - page not found',
            'summoner-not-found',
            'the summoner does not exist'
        ]
        if any(pattern in content for pattern in not_found_patterns):
            current_time = datetime.now().timestamp()
            last_notification = not_found_player_notifications.get(player_name, 0)
            
            # 3ÊôÇÈñìÔºà10800ÁßíÔºâÁµåÈÅé„Åó„Å¶„ÅÑ„Çå„Å∞ÈÄöÁü•
            if current_time - last_notification >= 10800:
                not_found_player_notifications[player_name] = current_time
                # „Éó„É¨„Ç§„É§„Éº„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇíÂèñÂæó
                category = PLAYER_CATEGORIES.get(player_name, 'friend')
                webhook = DiscordWebhook(
                    url=WEBHOOK_URLS[category],
                    content=f"‚ö†Ô∏è **Ê≥®ÊÑè**: „Éó„É¨„Ç§„É§„Éº `{display_name}` „ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„ÄÇ„Éó„É¨„Ç§„É§„ÉºÂêç„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                )
                webhook.execute()
            
            print('Âà§ÂÆöÁµêÊûú: „Éó„É¨„Ç§„É§„Éº„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì')
            return "not_found"
        
        # Â§ß„Åç„Å™„É¨„Çπ„Éù„É≥„Çπ„Éá„Éº„Çø„ÅÆÂèÇÁÖß„ÇíÂâäÈô§
        response = None
        
        # „É≠„Éº„Éá„Ç£„É≥„Ç∞Áä∂ÊÖã„ÅÆÁ¢∫Ë™ç
        loading_patterns = [
            'damn, that\'s pretty slow to load',
            'loadmessage',
            'spinner'
        ]
        if any(pattern in content for pattern in loading_patterns):
            # API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÇíÁõ¥Êé•Âëº„Å≥Âá∫„Åô
            api_url = f"https://porofessor.gg/partial/live-partial/jp/{url_player_name}"
            api_response = session.get(api_url, headers=headers, timeout=10)
            content = api_response.text
            
            # API„É¨„Çπ„Éù„É≥„Çπ„ÅÆHTML„É≠„Ç∞„ÇÇ‰øùÂ≠ò
            save_html_log(f"{player_name}_api", content)
            
            content = content.lower()
        
        # Ë©¶Âêà‰∏≠„ÅÆÂà§ÂÆö
        in_game_patterns = [
            'live-game-stats',
            'team stats',
            'game-status-ingame',
            'live game',
            'spectate'
        ]
        if any(pattern in content for pattern in in_game_patterns):
            # „Éû„ÉÉ„ÉÅID„ÅÆÂèñÂæó
            match_id = None
            result_td_start = content.find('class="resulttd"')
            if result_td_start != -1:
                href_start = content.find('href="https://www.leagueofgraphs.com/match/jp/', result_td_start)
                if href_start != -1:
                    href_end = content.find('#', href_start)
                    if href_end != -1:
                        start_pos = href_start + len('href="https://www.leagueofgraphs.com/match/jp/')
                        match_id = content[start_pos:href_end]

            if not match_id:
                logging.warning(f"„Éû„ÉÉ„ÉÅID„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: {player_name}")
                return
                
            # Ë©¶Âêà„Çø„Ç§„Éó„ÅÆÂà§ÂÆö
            game_type = "‰∏çÊòé"
            
            # h2„Çø„Ç∞„ÅÆÂÜÖÂÆπ„ÇíÊñáÂ≠óÂàóÊ§úÁ¥¢„ÅßÂèñÂæó
            h2_start = content.find('<h2 class="left relative">')
            if h2_start != -1:
                h2_end = content.find('</h2>', h2_start)
                if h2_end != -1:
                    game_type_text = content[h2_start:h2_end].split('\n')[1].strip().lower()
                    
                    # Ë©¶Âêà„Çø„Ç§„Éó„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞
                    type_mapping = {
                        'ranked solo/duo': 'RANKED SOLO/DUO',
                        'ranked flex': 'RANKED FLEX',
                        'normal (quickplay)': 'NORMAL',
                        'aram': 'ARAM',
                        'arena': 'ARENA',
                        'arurf 4v4': 'CUSTOM',
                    }
                    
                    game_type = type_mapping.get(game_type_text, "‰∏çÊòé")

            # „ÉÅ„É£„É≥„Éî„Ç™„É≥„ÅÆÂà§ÂÆö
            champion = "‰∏çÊòé"
            search_name = player_name.lower()
            
            # 1. „Éó„É¨„Ç§„É§„Éº„ÅÆ„Ç´„Éº„Éâ„ÇíË¶ã„Å§„Åë„Çã
            card_start = content.find(f'<div class="card card-5" data-summonername="{search_name}"')
            if card_start == -1:
                return
            
            # 2. box championbox„ÇíÊé¢„ÅôÔºàÂ∞èÊñáÂ≠ó„ÅßÊ§úÁ¥¢Ôºâ
            box_start = content.find('<div class="box championbox', card_start)
            if box_start == -1:
                box_start = content.find('class="championbox', card_start)
                if box_start == -1:
                    return
            
            # 3. imgFlex„ÇíÊé¢„ÅôÔºàÂ∞èÊñáÂ≠ó„ÅßÊ§úÁ¥¢Ôºâ
            img_flex_start = content.find('<div class="imgflex', box_start)
            if img_flex_start == -1:
                return
            
            # 4. imgColumn-champion„ÇíÊé¢„Åô
            img_column_start = content.find('<div class="imgcolumn-champion', img_flex_start)
            if img_column_start == -1:
                return
            
            # 5. relative requireTooltip„ÇíÊé¢„Åô
            tooltip_start = content.find('<div class="relative requiretooltip', img_column_start)
            if tooltip_start == -1:
                return
            
            # 6. tooltip„ÅÆÂ±ûÊÄß„ÇíÊé¢„Åô
            tooltip_class_start = content.find('tooltip="', tooltip_start)
            if tooltip_class_start == -1:
                return
            
            # 7. img src„ÅÆaltÂ±ûÊÄß„ÇíÊé¢„Åô
            alt_start = content.find('alt="', tooltip_class_start)
            if alt_start == -1:
                return
            
            alt_end = content.find('"', alt_start + 5)
            if alt_end == -1:
                return
            
            champion = content[alt_start + 5:alt_end].capitalize()
            
            # ÁèæÂú®„ÅÆ„Éû„ÉÉ„ÉÅÊÉÖÂ†±„Çí‰ΩúÊàê
            current_match = {
                'match_id': match_id,
                'player_name': player_name,
                'champion': champion,
                'game_type': game_type,
                'url': main_url,
                'timestamp': (datetime.now() + timedelta(hours=9)).timestamp()
            }
            
            # „Éó„É¨„Ç§„É§„Éº„ÅÆÂ±•Ê≠¥„ÇíÁÆ°ÁêÜ
            if player_name not in last_match_info:
                last_match_info[player_name] = []
            
            # Âêå„Åò„Éû„ÉÉ„ÉÅ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            for match in last_match_info[player_name]:
                if match['match_id'] == current_match['match_id']:
                    logging.info(f"Âêå„Åò„Éû„ÉÉ„ÉÅ„Çí„Éó„É¨„Ç§‰∏≠„ÅÆ„Åü„ÇÅ„ÄÅÈÄöÁü•„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô: {player_name} (Match ID: {match_id})")
                    return
            
            # Êñ∞„Åó„ÅÑ„Éû„ÉÉ„ÉÅ„ÇíËøΩÂä†
            last_match_info[player_name].append(current_match)
            
            # 2„Éû„ÉÉ„ÉÅ„ÇíË∂Ö„ÅàÂ†¥Âêà„ÄÅÊúÄ„ÇÇÂè§„ÅÑ„Éû„ÉÉ„ÉÅ„ÇíÂâäÈô§
            if len(last_match_info[player_name]) > MAX_MATCHES_PER_PLAYER:
                # „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Åß‰∏¶„Å≥Êõø„Åà„Å¶Âè§„ÅÑ„ÇÇ„ÅÆ„ÇíÂâäÈô§
                last_match_info[player_name].sort(key=lambda x: x['timestamp'], reverse=True)
                last_match_info[player_name] = last_match_info[player_name][:MAX_MATCHES_PER_PLAYER]
            
            logging.info(f'Âà§ÂÆöÁµêÊûú: Ë©¶Âêà‰∏≠„Åß„ÅôÔºà{game_type}Ôºâ- {champion}')
            return current_match  # „Éû„ÉÉ„ÉÅÊÉÖÂ†±„ÇíËøî„Åô„ÅÆ„Åø

        # Ë©¶Âêà‰∏≠„Åß„ÅØ„Å™„ÅÑÂ†¥ÂêàÔøΩÔøΩÂà§ÂÆö
        not_in_game_patterns = [
            'the summoner is not in-game',
            'summoner-offline',
            'not in-game',
            'please retry later',
            'must be on the loading screen'
        ]
        if any(pattern in content for pattern in not_in_game_patterns):
            print('Âà§ÂÆöÁµêÊûú: „Éó„É¨„Ç§„É§„Éº„ÅØË©¶Âêà‰∏≠„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì')
            return None  # Ë©¶Âêà‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅØNone„ÇíËøî„Åô
        else:
            # „Ç≤„Éº„É†‰∏≠„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆÂá¶ÁêÜ
            if player_name in last_match_info:
                # ÊúÄÊñ∞„ÅÆ5„Éû„ÉÉ„ÉÅ„ÅØ‰øùÊåÅ
                matches = last_match_info[player_name]
                if matches:
                    matches.sort(key=lambda x: x['timestamp'], reverse=True)
                    last_match_info[player_name] = matches[:MAX_MATCHES_PER_PLAYER]
        print('„É¨„Çπ„Éù„É≥„Çπ„Çπ„ÉÜ„Éº„Çø„Çπ:', response.status_code)
        print('„É¨„Çπ„Éù„É≥„ÇπÂÜÖÂÆπ„ÅÆ‰∏ÄÈÉ®:', content[:500])
        print('Âà§ÂÆöÁµêÊûú: Áä∂ÊÖã„ÇíÁâπÂÆö„Åß„Åç„Åæ„Åõ„Çì')
        
    except Exception as e:
        category = PLAYER_CATEGORIES.get(player_name, 'friend')
        webhook = DiscordWebhook(
            url=WEBHOOK_URLS[category],
            content=f"‚ö†Ô∏è **„Ç®„É©„Éº**: `{PLAYER_DICT[player_name]}` (`{player_name}`) „ÅÆÊÉÖÂ†±ÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ\n„Éó„É¨„Ç§„É§„ÉºÂêç„ÅåÈñìÈÅï„Å£„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁ¢∫Ë™ç„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ"
        )
        webhook.execute()
        print(f'„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}')
        return "error"

def cleanup_old_data():
    """Âè§„ÅÑ„Éá„Éº„Çø„ÇíÂÆöÊúüÁöÑ„Å´ÂâäÈô§Ôºà1.5ÊôÇÈñì‰ª•‰∏äÁµåÈÅé„Åó„Åü„ÇÇ„ÅÆ„ÇíÂØæË±°Ôºâ"""
    current_time = datetime.now().timestamp()
    cleanup_threshold = 5400  # 1.5ÊôÇÈñì = 5400Áßí
    
    for player in list(last_match_info.keys()):
        matches = last_match_info[player]
        # 1.5ÊôÇÈñì‰ª•‰∏äÂâç„ÅÆ„Éá„Éº„Çø„ÇíÂâäÈô§
        last_match_info[player] = [
            match for match in matches 
            if current_time - match['timestamp'] < cleanup_threshold
        ]
        
        # „Éá„Éº„Çø„ÅåÂâäÈô§„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„É≠„Ç∞„Å´Ë®òÈå≤
        removed_count = len(matches) - len(last_match_info[player])
        if removed_count > 0:
            logging.info(f"{player}„ÅÆÂè§„ÅÑ„Éû„ÉÉ„ÉÅ„Éá„Éº„Çø{removed_count}‰ª∂„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü")

def cleanup_old_notifications():
    """3ÊôÇÈñì‰ª•‰∏äÁµåÈÅé„Åó„ÅüÈÄöÁü•Â±•Ê≠¥„ÇíÂâäÈô§"""
    current_time = datetime.now().timestamp()
    for player_name in list(not_found_player_notifications.keys()):
        if current_time - not_found_player_notifications[player_name] >= 10800:
            del not_found_player_notifications[player_name]

def main():
    logging.info("LoLË©¶ÂêàÁõ£Ë¶ñ„ÇíÈñãÂßã„Åó„Åæ„Åô")
    logging.info("Áõ£Ë¶ñÂØæË±°„Éó„É¨„Ç§„É§„Éº:")
    for player_name, nickname in PLAYER_DICT.items():
        logging.info(f"- {nickname} ({player_name})")
    
    while True:
        try:
            cleanup_old_data()
            cleanup_old_notifications()  # ÈÄöÁü•Â±•Ê≠¥„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÇíËøΩÂä†
            check_all_players()
            time.sleep(300)
            
        except Exception as e:
            logging.error(f"‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}")
            time.sleep(300)
            continue

if __name__ == "__main__":
    main()